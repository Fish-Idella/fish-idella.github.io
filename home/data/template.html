<hr id="puset-interpreter-template" />

<template id="link-list">
    <style>
        .scroll {
            width: auto;
            max-width: 75%;
            height: 80%;
            scrollbar-width: none;
            overflow: hidden scroll;
            place-items: center;
            place-content: start space-around;
            /* grid-row-gap: 1rem; */
            grid-template-columns: repeat(auto-fill, minmax(6rem, 1fr));
        }

        .scroll>a {
            position: relative;
            display: flex;
            min-width: 6rem;
            height: 6rem;
            flex-direction: column;
            place-items: center;
            place-content: center;
            text-align: center;
            text-decoration: none;
            font-weight: 400;
            /* aspect-ratio: 1; */
            text-shadow: 0 0 5px var(--text-shadow);
            transition: transform 100ms ease-in-out;
        }

        .scroll>a:hover {
            transform: scale(1.2);
        }

        span.bg {
            width: 3rem;
            height: 3rem;
            margin: 0.5rem;
            border-radius: 23%;
            background-color: var(--background-search);
            background-size: contain;
            filter: var(--grayscale);
        }

        span.title {
            font-size: 0.8rem;
            text-overflow: ellipsis;
            /* -webkit-text-stroke: 0.1px black; */
            white-space: nowrap;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
    </style>
    <div class="scroll grid-horizontal">
        <a class="link-button unselect" v-hide="true" draggable="true"><span class="bg"></span><span
                class="title">模板</span></a>
        <a class="add-link-button unselect" href="javascript:;" draggable="false" v-hide="true">
            <span class="bg" style="background-image: url(/mediae/icons/24d2dcee7c1a84a8a889a3ff87f18971.jpeg);"></span>
            <span class="title">添加</span>
        </a>
    </div>
    <script>
        return function (target, settings, options) {
            const scroll = target.querySelector('.scroll');
            scroll.addEventListener('contextmenu', PuSet.delegation('a.link-button', function (event) {
                event.preventDefault();
                settings.openLinkManager(this.dataset.key);
            }));
            const addLinkButton = scroll.querySelector('a.add-link-button');
            settings.vm_links = PuSet.ViewManager({
                target: scroll,
                selector: 'a.link-button',
                insert: addLinkButton,
                data: settings.map_all_links,
                onresize(target, value, key) {
                    // 火狐浏览器不会自动撑大grid布局
                    if ("length" === key) {
                        const max = addLinkButton.style.order = (+value + 10);
                        target.style.width = `${max * 80}px`;
                    }
                },
                layout(target, value, key, index) {
                    target.dataset.key = key;
                    target.style.order = index + 1;
                    target.href = value.href;
                    const background = target.querySelector("span.bg");
                    background.style.setProperty("background-color", value.background_color ?? "transparent");
                    background.style.setProperty("background-image", `url(${value.local_icon || value.icon || (new URL("/favicon.ico", value.href)).href})`);
                    target.querySelector("span.title").innerHTML = value.title;
                }
            });
        }
    </script>
</template>

<template id="link-manager">
    <div id="link-manager" class="view dialog hide">
        <div class="flex-vertical dialog-box">
            <div class="flex-horizontal top">
                <div class="fill title">链接管理器<span class="help-hover" title="">ⓘ</span></div>
                <div class="button-box">
                    <button class="delete">删除</button>
                    <button class="save">保存</button>
                    <button class="close">关闭</button>
                </div>
            </div>
            <div class="fill dialog-content flex-horizontal">
                <div class="preview flex-horizontal">
                    <a class="link-button unselect" draggable="true"><span class="bg"></span><span
                            class="title">预览</span></a>
                </div>
                <div class="fill input-box">
                    <div class="subtitle">标题：</div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-title" value="预览"
                            autocomplete="off"></div>
                    <div class="subtitle">网址：</div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-url"
                            autocomplete="off"></div>
                    <div class="subtitle flex-horizontal space"><span>图标网址：（临时加载一次后缓存到浏览器存储）</span><label
                            class="checkbox"><input type="checkbox" id="link-manager-image-always"><span
                                class="text">每次都从网络加载</span></label></div>
                    <div class="input flex-vertical"><input class="unify" type="url" id="link-manager-image-url"
                            autocomplete="off"></div>
                    <div class="subtitle">图标缓存：（点击左侧预览图标可更换为本地图片）</div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-image-local"
                            readonly="readonly" autocomplete="off"></div>
                    <div class="subtitle flex-horizontal"><span>背景颜色：颜色选择器：</span><input class="unify" type="color"
                            id="link-manager-background-selector" value="#ffffff"><span>（实际以预览效果为准）</span></div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-background"
                            value="#ffffff" autocomplete="off"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        return function (root, MainUI, options) {
            const _link_manager = document.getElementById("link-manager");

            const _preview = _link_manager.querySelector(".preview");
            const _preview_background = _preview.querySelector(".preview>.link-button>span.bg");
            const _preview_title = _preview.querySelector(".preview>.link-button>span.title");

            const toString = (string, def = "") => String(string ? string : def);
            const _link_manager_input = {
                "title": {
                    e: _link_manager.querySelector("input#link-manager-title"),
                    set(string) {
                        _preview_title.textContent = this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "href": {
                    e: _link_manager.querySelector("input#link-manager-url"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "icon": {
                    e: _link_manager.querySelector("input#link-manager-image-url"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "local_icon": {
                    e: _link_manager.querySelector("input#link-manager-image-local"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "always": {
                    e: _link_manager.querySelector("input#link-manager-image-always"),
                    set(string) {
                        if (this.e.checked = Boolean(string)) {
                            _preview_background.style.setProperty("background-image", `url(${_link_manager_input.icon.e.value}))`);
                        } else {
                            _preview_background.style.setProperty("background-image", `url(${_link_manager_input.local_icon.e.value})`);
                        }
                    },
                    get() {
                        return this.e.checked
                    }
                },
                "background_color": {
                    e: _link_manager.querySelector("input#link-manager-background"),
                    set(string) {
                        const value = _link_manager_input.background_color.e.value = toString(string, "transparent");
                        _preview_background.style.setProperty("background-color", value);
                    },
                    get() {
                        return this.e.value.trim() || "transparent";
                    }
                },
                "selector": {
                    e: _link_manager.querySelector("#link-manager-background-selector"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                }
            };

            const needSaveKeys = ["title", "href", "icon", "local_icon", "always", "background_color"];
            _link_manager.querySelector(".close").addEventListener("click", function () {
                _link_manager.classList.add("hide");
            }, false);
            _link_manager.querySelector(".delete").addEventListener("click", function () {
                const id = Number(_link_manager.dataset.id);
                if (id < 0) {
                    return
                }
                if (confirm("确定要删除吗？")) {
                    MainUI.vm_links.data.splice(id, 1);
                    saveLocalConfigure();
                    _link_manager.classList.add("hide");
                }
            }, false);
            _link_manager.querySelector(".save").addEventListener("click", function () {

                const result = needSaveKeys.reduce(function (acc, key) {
                    acc[key] = _link_manager_input[key].get();
                    return acc;
                }, {});

                if (!result.href) {
                    return alert("网址不能为空！")
                }

                const id = Number(_link_manager.dataset.id);
                if (id < 0) {
                    MainUI.vm_links.data.push(result);
                } else {
                    MainUI.vm_links.data.splice(id, 1, result);
                }

                saveLocalConfigure();
                _link_manager.classList.add("hide");
            });

            _link_manager_input.title.e.addEventListener("input", function () {
                _preview_title.textContent = _link_manager_input.title.e.value;
            });
            _link_manager_input.icon.e.addEventListener("change", function () {
                // TODO
            });
            _preview_background.addEventListener("click", function () {
                ImageSelector(function (blob) {
                    MainUI.loadImage(URL.createObjectURL(blob))
                        .then(image => MainUI.compressImage(image, 128, 128))
                        .then(function (dataURL) {
                            _link_manager_input.icon.e.value = "";
                            _preview_background.style.setProperty("background-image", `url(${_link_manager_input.local_icon.e.value = dataURL})`);
                        });
                });
            });
            _link_manager_input.selector.e.addEventListener("change", function () {
                _preview_background.style.setProperty("background-color", _link_manager_input.background_color.e.value = _link_manager_input.selector.e.value);
            });
            _link_manager_input.background_color.e.addEventListener("change", function () {
                _preview_background.style.setProperty("background-color", _link_manager_input.background_color.e.value);
            });

            MainUI.openLinkManager = function openLinkManager(index = "-1") {
                if ((_link_manager.dataset.id = index) >= 0) {
                    if (index >= MainUI.vm_links.data.length) {
                        return console.warn("IndexOutOfBoundsException");
                    }
                    const obj = MainUI.vm_links.data[index];
                    for (let key in obj) _link_manager_input[key]?.set(obj[key]);
                }
                _link_manager.classList.remove("hide");
            };
        }
    </script>
</template>

<template id="image-selector">
    <style>
        /* 对话框整体样式 */
        .image-selector-dialog {
            user-select: none;
            border: none;
            outline: none;
            border-radius: 1rem;
            box-shadow: rgba(138, 122, 122, 0.8) 1px 1px 4px 0px;
        }

        /* 主体容器 */
        .box {
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 顶部标题栏 */
        .top {
            display: flex;
            line-height: 50px;
            font-size: 1.3rem;
        }

        .title {
            flex-grow: 1;
            font-weight: 300;
            /* 标题加粗 */
        }

        /* 自定义按钮样式 */
        .custom-button {
            font-size: 1rem;
            text-align: center;
            vertical-align: middle;
            padding: 6px;
            /* 左右内边距稍微加大一点 */
            margin: 0px 0.5rem;
            border: 1px solid rgb(187, 187, 187);
            border-radius: 0.4rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            /* 增加过渡效果 */
        }

        .custom-button:hover {
            background-color: #f0f0f0;
            /*  hover 效果 */
        }

        .custom-button:active {
            background-color: #e0e0e0;
            /* active 效果 */
        }

        /* 隐藏实际的 input 元素 */
        .custom-button input[type="file"],
        .custom-button input[type="button"] {
            appearance: none;
            width: 0px;
            height: 0px;
            padding: 0px;
            margin: 0px;
            border: none;
            background: none;
        }

        /* 预览区域 */
        .preview {
            position: relative;
            width: 600px;
            height: 400px;
            overflow: hidden;
            background-color: rgb(243, 244, 246);
            background-image: linear-gradient(45deg, rgb(229, 231, 235) 25%, transparent 25%),
                linear-gradient(-45deg, rgb(229, 231, 235) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgb(229, 231, 235) 75%),
                linear-gradient(-45deg, transparent 75%, rgb(229, 231, 235) 75%);
            background-size: 20px 20px;
            background-position: 0px 0px, 0px 10px, 10px -10px, -10px 0px;
        }

        /* 画布 */
        .preview canvas {
            position: absolute;
            top: 0px;
            left: 0px;
            pointer-events: none;
            margin: 0px;
            /* width 和 height 最好在 JS 中设置，以匹配其绘制的图像 */
        }

        /* 遮罩层 (裁剪框) */
        .overlay {
            position: absolute;
            width: 256px;
            height: 256px;
            top: 50%;
            left: 50%;
            pointer-events: none;
            /* 让鼠标事件穿透到下方的预览区 */
            transform: translate(-50%, -50%);
            border: 1px solid rgb(102, 102, 102);
            box-sizing: border-box;
            background-color: transparent;
            box-shadow: rgba(0, 0, 0, 0.8) 0px 0px 0px 2000px;
            /* 使用一个大的 spread 来创建半透明遮罩 */
            background-image: linear-gradient(transparent 0%, transparent 33.13%, rgb(102, 102, 102) 33.13%, rgb(102, 102, 102) 33.53%, transparent 33.53%),
                linear-gradient(transparent 66.46%, rgb(102, 102, 102) 66.46%, rgb(102, 102, 102) 66.86%, transparent 66.86%),
                linear-gradient(to right, transparent 0%, transparent 33.13%, rgb(102, 102, 102) 33.13%, rgb(102, 102, 102) 33.53%, transparent 33.53%),
                linear-gradient(to right, transparent 66.46%, rgb(102, 102, 102) 66.46%, rgb(102, 102, 102) 66.86%, transparent 66.86%);
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }
    </style>

    <dialog class="image-selector-dialog">
        <div class="box">
            <div class="top">
                <div class="title">图片选择器</div>
                <div>
                    <label class="custom-button" tabindex="0">
                        <input type="file" accept="image/*" tabindex="-1">
                        <span>选择文件</span>
                    </label>
                </div>
                <div>
                    <label class="custom-button" tabindex="0">
                        <input type="button" value="确认" tabindex="-1">
                        <span>确认</span>
                    </label>
                </div>
            </div>
            <div class="preview">
                <canvas width="600" height="400"></canvas>
                <div class="overlay"></div>
            </div>
        </div>
    </dialog>

    <script>
        const overlay = 256;
        /**
         * 将值限制在 [min, max] 范围内
         * @param {number} value - 输入值
         * @param {number} min - 最小值
         * @param {number} max - 最大值
         * @returns {number} 限制后的值
         */
        const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

        /**
         * 计算并限制偏移量，使其不超过基于图像尺寸和缩放比例的安全范围
         * @param {number} offset - 当前偏移量（如 offsetX 或 offsetY）
         * @param {number} imageDimension - 图像的宽度或高度
         * @param {number} scale - 当前缩放比例
         * @returns {number} 限制后的偏移量
         */
        function calculateBoundedOffset(offset, imageDimension, scale) {
            const safeEdge = (imageDimension - overlay / scale) / 2;
            return clamp(offset, -safeEdge, safeEdge);
        }

        return function (root, settings, options) {
            "use strict";

            const dialog = root.querySelector("dialog");
            const fileInput = dialog.querySelector("input[type=file]");
            const confirmInput = dialog.querySelector("input[type=button]");
            const previewDiv = dialog.querySelector(".preview");
            const canvas = previewDiv.querySelector("canvas");
            const ctx = canvas.getContext("2d", { willReadFrequently: true });

            let img, mCallback;
            settings.openImageSelector = function openImageSelector(callback) {
                mCallback = callback;
                dialog.showModal();
            };

            // 缩放和平移参数
            let minWidth = 0;
            let scale = 1;
            let minScale = 0.1;
            let maxScale = 10;
            let offsetX = 0;
            let offsetY = 0;


            let lastOffsetX, lastOffsetY;

            // 鼠标状态
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;


            // 绘制图片
            function drawImage() {

                // 边界限制
                offsetX = calculateBoundedOffset(offsetX, img.width, scale);
                offsetY = calculateBoundedOffset(offsetY, img.height, scale);

                if (offsetX === lastOffsetX && offsetY === lastOffsetY) {
                    return;
                }

                lastOffsetX = offsetX, lastOffsetY = offsetY;


                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 保存当前状态
                ctx.save();

                // 应用变换
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(scale, scale);

                ctx.translate(offsetX, offsetY);

                // 绘制图片（居中）
                ctx.drawImage(img, -img.width / 2, -img.height / 2);

                // 恢复状态
                ctx.restore();

            }

            document.addEventListener("keydown", function (ev) {
                if (dialog.open && img) {
                    // console.log(ev.code, ev.keyCode)
                    if (ev.code === "Space" || ev.keyCode === 32) {
                        ev.preventDefault();
                        offsetX = 0, offsetY = 0;
                    } else if (ev.code === "ArrowLeft" || ev.keyCode === 37 || ev.code === "keyA" || ev.keyCode === 65) {
                        ev.preventDefault();
                        offsetX -= 1;
                    } else if (ev.code === "ArrowRight" || ev.keyCode === 39 || ev.code === "keyD" || ev.keyCode === 68) {
                        ev.preventDefault();
                        offsetX += 1;
                    } else if (ev.code === "ArrowUp" || ev.keyCode === 38 || ev.code === "keyW" || ev.keyCode === 87) {
                        ev.preventDefault();
                        offsetY -= 1;
                    } else if (ev.code === "ArrowDown" || ev.keyCode === 40 || ev.code === "keyS" || ev.keyCode === 83) {
                        ev.preventDefault();
                        offsetY += 1;
                    }
                    drawImage();
                }
            });

            // 鼠标滚轮事件处理
            previewDiv.addEventListener('wheel', function (e) {
                e.preventDefault();

                // 获取鼠标在Canvas上的位置
                const rect = canvas.getBoundingClientRect();
                const pointerX = e.clientX - rect.left;
                const pointerY = e.clientY - rect.top;

                // 计算鼠标在图片坐标系中的位置
                const imgX = (pointerX - canvas.width / 2) / scale - offsetX;
                const imgY = (pointerY - canvas.height / 2) / scale - offsetY;

                // 计算缩放因子
                const delta = -e.deltaY;
                let factor = 0.01;
                if (delta < 0) {
                    factor = -0.01;
                }

                // 应用缩放限制
                const newScale = Math.min(Math.max(scale + factor, minScale), maxScale);

                // 计算新的偏移量，使缩放以鼠标位置为中心
                offsetX = (pointerX - canvas.width / 2) / newScale - imgX;
                offsetY = (pointerY - canvas.height / 2) / newScale - imgY;

                scale = newScale;

                drawImage();
            });

            // 鼠标拖动事件处理
            previewDiv.addEventListener('pointerdown', function (e) {
                e.preventDefault();
                if (!img) return;
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            dialog.addEventListener('pointermove', function (e) {
                e.preventDefault();
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;

                    offsetX += dx / scale;
                    offsetY += dy / scale;

                    lastX = e.clientX;
                    lastY = e.clientY;

                    drawImage();
                }
            });

            dialog.addEventListener('pointerup', function (e) {
                e.preventDefault();
                isDragging = false;
            });


            // 加载新图片
            fileInput.addEventListener("input", function (event) {
                event.preventDefault();
                if (fileInput.files.length === 0) return;
                img = new Image();
                img.addEventListener("load", function () {
                    minWidth = Math.min(img.naturalWidth, img.naturalHeight)
                    minScale = overlay / minWidth;
                    scale = minScale;
                    offsetX = 0;
                    offsetY = 0;
                    drawImage();
                }, { once: true });
                img.src = URL.createObjectURL(fileInput.files.item(0));
            });


            // 添加确认裁剪功能
            confirmInput.addEventListener("click", function cropImage(event) {
                event.preventDefault();
                event.stopPropagation();
                dialog.close();

                if (!img) return;

                const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = canvas.height = overlay;
                const ctx2 = canvas.getContext("2d");
                ctx2.putImageData(ctx.getImageData(172, 72, overlay, overlay), 0, 0);
                canvas.toBlob(mCallback, "image/png", 1);
            });
        }
    </script>

</template>
