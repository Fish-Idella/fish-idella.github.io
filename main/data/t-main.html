<!-- 必须的标签和 id, 告知解释器这是一个模板文件 -->
<!-- 只解释 hr 标签之后的内容 -->
<hr id="puset-interpreter-template" />

<template id="reset">
    <style>
        .crimson {
            color: crimson;
        }
    </style>
    <dialog class="reset">
        <div class="flex-vertical dialog-box">
            <div class="top">重置用户数据</div>
            <div class="tips">⚠ 即将重置用户在本网站的本地数据。</div>
            <div><span class="crimson">继续重置操作</span><span>请点击</span><button type="button"
                    class="ok">确认</button><span>。</span>
            </div>
            <div>退出操作请按<button type="button" class="esc">Esc</button>键关闭窗口。</div>
        </div>
    </dialog>
    <script>
        return function a(root, MainUI, options) {
            const init = function () {
                fetch(`data/save.json?${Date.now()}`).then(a => a.json())
                    .then(json => storage.setItem("puset-local-configure", btoa(encodeURIComponent(JSON.stringify(json)))))
                    .then(() => window.location.reload(true));
            };
            MainUI.default_configuration = function () {
                root.querySelector("button").addEventListener("click", init, { once: true });
                return (MainUI.GS === null) ? init() : root.querySelector("dialog").showModal();
            }
        }
    </script>
</template>

<template id="background">
    <div part="background" class="view wallpaper background">
        <video class="view wallpaper" muted="muted" loop="loop" autoplay="autoplay"></video>
        <canvas class="view wallpaper d2 hide"></canvas>
        <canvas class="view wallpaper d3 hide"></canvas>
    </div>
    <script>
        "use strict";

        // 设置隐藏属性和可见性变化事件的名称
        const { hidden, visibilitychange } = (() => {
            if (typeof document.hidden !== "undefined") {
                return { hidden: "hidden", visibilitychange: "visibilitychange" };
            } else if (typeof document.msHidden !== "undefined") {
                return { hidden: "msHidden", visibilitychange: "msvisibilitychange" };
            } else if (typeof document.webkitHidden !== "undefined") {
                return { hidden: "webkitHidden", visibilitychange: "webkitvisibilitychange" };
            }
            return { hidden: "", visibilitychange: "" };
        })();

        // 重构为返回Promise的形式，便于使用async/await
        function getResponseHeader(path) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.onerror = reject;
                xhr.onreadystatechange = function () {
                    if (this.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                        xhr.abort();
                        resolve(String(xhr.getResponseHeader("Content-Type") || "color"));
                    }
                };
                xhr.open("GET", path);
                xhr.responseType = "blob";
                xhr.send();
            });
        }

        /**
         * 用户自定义的背景处理函数
         * @param {Element} target 
         * @param {*} settings 保存的设置
         * @param {*} options 设置相关的属性
         */
        return function background(target, MainUI, options) {
            "use strict";

            // 获取DOM元素
            const mBackground = target.querySelector('div.background');
            const mVideo = mBackground.querySelector('video.wallpaper');
            const mCanvas2D = mBackground.querySelector("canvas.d2");
            const mCanvas3D = mBackground.querySelector("canvas.d3");

            // 状态对象
            const state = {
                hide: false,
                dx: 0,
                dy: 0,
                dw: mBackground.clientWidth,
                dh: mBackground.clientHeight
            };

            // 初始化画布尺寸
            mCanvas2D.width = mCanvas3D.width = state.dw;
            mCanvas2D.height = mCanvas3D.height = state.dh;

            // 画布上下文
            const ctx = mCanvas2D.getContext("2d", { alpha: true });
            const webgl = mCanvas3D.getContext("webgl", { alpha: true });
            let isVideo = false;

            // 视频初始化函数
            const initVideo = () => {
                mVideo.muted = true;
                mVideo.loop = true;
                mVideo.src = "";
                mVideo.setAttribute("poster", MainUI.a);
                mVideo.removeAttribute("style");
            };

            // 视频控制函数
            const pauseVideo = () => mVideo.pause();
            const playVideo = () => mVideo.play();

            // 可见性变化处理
            document.addEventListener(visibilitychange, () => {
                state.hide = document[hidden];
                if (isVideo) {
                    state.hide ? pauseVideo() : playVideo();
                }
            });

            // 窗口大小调整处理
            window.addEventListener("resize", () => {
                const w = mBackground.clientWidth;
                const h = mBackground.clientHeight;

                state.dx = 0;
                state.dy = 0;
                state.dw = w;
                state.dh = h;

                mCanvas2D.width = w;
                mCanvas2D.height = h;
                mCanvas3D.width = w;
                mCanvas3D.height = h;
            });

            // 加载图片背景
            const loadImageBackground = async (path) => {
                await MainUI.loadImage(path);
                initVideo();
                mBackground?.setAttribute("style", `background-image:url(${path});`);
                mBackground?.animate(
                    [{ opacity: 0 }, { opacity: 1 }],
                    { duration: 1000, iterations: 1 }
                );
            };

            // 处理动画类型背景
            const handleAnimation = async (path) => {
                try {
                    const response = await fetch(path);
                    const script = await response.text();
                    const fn = eval(script);
                    if (typeof fn === "function") {
                        fn(ctx, webgl, state);
                    }
                } catch (error) {
                    console.error("Error loading animation:", path, error);
                }
            };

            // 处理视频类型背景
            const handleVideo = (path, type) => {
                initVideo();
                mVideo.type = type;
                mVideo.src = path;
                playVideo();
                isVideo = true;
            };

            // 处理文件类型背景
            const handleFile = async () => {
                try {
                    const file = await storage.getItem("puset-local-wallpaper");
                    if (file) {
                        MainUI.loadBackground(URL.createObjectURL(file), file.type);
                    } else {
                        console.warn("本地壁纸丢失");
                        loadImageBackground('/api/random_wallpaper_provider.php');
                    }
                } catch (error) {
                    console.error("Error handling file background:", error);
                }
            };

            // 处理Bing壁纸
            const handleBing = async () => {
                let localFile = null;
                try {
                    localFile = await storage.getItem("puset-local-wallpaper-bing");
                    if (localFile && MainUI.isToday(localFile.lastModifiedDate)) {
                        MainUI.loadBackground(URL.createObjectURL(localFile), localFile.type);
                        return;
                    }
                } catch (error) {
                    console.log("Bing wallpaper is overdue or not found");
                }

                try {
                    const response = await fetch(`/api/domain_whitelist_proxy.php?url=${encodeURIComponent(MainUI.background.bing)}`);
                    const json = await response.json();
                    const imageUrl = new URL(json?.images?.[0]?.url, MainUI.background.bing).href;
                    const img = await MainUI.loadImage(imageUrl, true);

                    const canvas = document.createElement("canvas");
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    canvas.getContext("2d").drawImage(img, 0, 0);

                    canvas.toBlob(blob => {
                        localFile = new File([blob], "wallpaper", { type: blob.type });
                        storage.setItem("puset-local-wallpaper-bing", localFile);
                        MainUI.loadBackground(URL.createObjectURL(localFile), localFile.type);
                    });
                } catch (error) {
                    console.warn("无法获取最新 bing 壁纸", error);
                    if (localFile) {
                        MainUI.loadBackground(URL.createObjectURL(localFile), localFile.type);
                    } else {
                        loadImageBackground('/api/random_wallpaper_provider.php');
                    }
                }
            };

            // 加载背景主函数
            MainUI.loadBackground = async (path, type) => {
                try {
                    // 确定背景类型
                    const contentType = type || await getResponseHeader(path);

                    // 暂停当前视频（如果有）
                    pauseVideo();
                    isVideo = false;

                    // 根据类型处理不同的背景

                    if (contentType.startsWith("image")) {
                        await loadImageBackground(path);
                        return;
                    }

                    if (contentType.startsWith("file")) {
                        await handleFile();
                        return;
                    }

                    if (contentType.startsWith("video")) {
                        handleVideo(path, contentType);
                        return;
                    }

                    if (contentType.startsWith("random")) {
                        await loadImageBackground('/api/random_wallpaper_provider.php');
                        return;
                    }

                    if (contentType.startsWith("bing")) {
                        await handleBing();
                        return;
                    }

                    if (contentType.startsWith("animation")) {
                        await handleAnimation(path);
                        return;
                    }

                    // 默认情况：纯色背景，如：background: #000;
                    initVideo();
                    mBackground.setAttribute("style", `background:${path}`);

                } catch (error) {
                    console.error("Error loading background:", error);
                }
            };

            // 暴露目标元素
            // options.target = mBackground;

            // 初始化背景
            const GS = MainUI.GS;
            MainUI.loadBackground(GS.string_background_src, GS.string_background_type);
        };
    </script>
</template>

<template id="image-selector">
    <style>
        /* 对话框整体样式 */
        .image-selector-dialog {
            user-select: none;
            border: none;
            outline: none;
            border-radius: 1rem;
            box-shadow: rgba(138, 122, 122, 0.8) 1px 1px 4px 0px;
        }

        /* 主体容器 */
        .box {
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 顶部标题栏 */
        .top {
            display: flex;
            line-height: 50px;
            font-size: 1.3rem;
        }

        .title {
            flex-grow: 1;
            font-weight: 300;
            /* 标题加粗 */
        }

        /* 自定义按钮样式 */
        .custom-button {
            font-size: 1rem;
            text-align: center;
            vertical-align: middle;
            padding: 6px;
            /* 左右内边距稍微加大一点 */
            margin: 0px 0.5rem;
            border: 1px solid rgb(187, 187, 187);
            border-radius: 0.4rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            /* 增加过渡效果 */
        }

        .custom-button:hover {
            background-color: #f0f0f0;
            /*  hover 效果 */
        }

        .custom-button:active {
            background-color: #e0e0e0;
            /* active 效果 */
        }

        /* 隐藏实际的 input 元素 */
        .custom-button input[type="file"],
        .custom-button input[type="button"] {
            appearance: none;
            width: 0px;
            height: 0px;
            padding: 0px;
            margin: 0px;
            border: none;
            background: none;
        }

        /* 预览区域 */
        .preview {
            position: relative;
            width: 600px;
            height: 400px;
            overflow: hidden;
            background-color: rgb(243, 244, 246);
            background-image: linear-gradient(45deg, rgb(229, 231, 235) 25%, transparent 25%),
                linear-gradient(-45deg, rgb(229, 231, 235) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgb(229, 231, 235) 75%),
                linear-gradient(-45deg, transparent 75%, rgb(229, 231, 235) 75%);
            background-size: 20px 20px;
            background-position: 0px 0px, 0px 10px, 10px -10px, -10px 0px;
        }

        /* 画布 */
        .preview canvas {
            position: absolute;
            top: 0px;
            left: 0px;
            pointer-events: none;
            margin: 0px;
            /* width 和 height 最好在 JS 中设置，以匹配其绘制的图像 */
        }

        /* 遮罩层 (裁剪框) */
        .overlay {
            position: absolute;
            width: 256px;
            height: 256px;
            top: 50%;
            left: 50%;
            pointer-events: none;
            /* 让鼠标事件穿透到下方的预览区 */
            transform: translate(-50%, -50%);
            border: 1px solid rgb(102, 102, 102);
            box-sizing: border-box;
            background-color: transparent;
            box-shadow: rgba(0, 0, 0, 0.8) 0px 0px 0px 2000px;
            /* 使用一个大的 spread 来创建半透明遮罩 */
            background-image: linear-gradient(transparent 0%, transparent 33.13%, rgb(102, 102, 102) 33.13%, rgb(102, 102, 102) 33.53%, transparent 33.53%),
                linear-gradient(transparent 66.46%, rgb(102, 102, 102) 66.46%, rgb(102, 102, 102) 66.86%, transparent 66.86%),
                linear-gradient(to right, transparent 0%, transparent 33.13%, rgb(102, 102, 102) 33.13%, rgb(102, 102, 102) 33.53%, transparent 33.53%),
                linear-gradient(to right, transparent 66.46%, rgb(102, 102, 102) 66.46%, rgb(102, 102, 102) 66.86%, transparent 66.86%);
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }
    </style>

    <dialog class="image-selector-dialog">
        <div class="box">
            <div class="top">
                <div class="title">图片选择器</div>
                <div>
                    <label class="custom-button" tabindex="0">
                        <input type="file" accept="image/*" tabindex="-1">
                        <span>选择文件</span>
                    </label>
                </div>
                <div>
                    <label class="custom-button" tabindex="0">
                        <input type="button" value="确认" tabindex="-1">
                        <span>确认</span>
                    </label>
                </div>
            </div>
            <div class="preview">
                <canvas width="600" height="400"></canvas>
                <div class="overlay"></div>
            </div>
        </div>
    </dialog>

    <script>
        const overlay = 256;
        /**
         * 将值限制在 [min, max] 范围内
         * @param {number} value - 输入值
         * @param {number} min - 最小值
         * @param {number} max - 最大值
         * @returns {number} 限制后的值
         */
        const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

        /**
         * 计算并限制偏移量，使其不超过基于图像尺寸和缩放比例的安全范围
         * @param {number} offset - 当前偏移量（如 offsetX 或 offsetY）
         * @param {number} imageDimension - 图像的宽度或高度
         * @param {number} scale - 当前缩放比例
         * @returns {number} 限制后的偏移量
         */
        function calculateBoundedOffset(offset, imageDimension, scale) {
            const safeEdge = (imageDimension - overlay / scale) / 2;
            return clamp(offset, -safeEdge, safeEdge);
        }

        return function (root, MainUI, options) {
            "use strict";

            const dialog = root.querySelector("dialog");
            const fileInput = dialog.querySelector("input[type=file]");
            const confirmInput = dialog.querySelector("input[type=button]");
            const previewDiv = dialog.querySelector(".preview");
            const canvas = previewDiv.querySelector("canvas");
            const ctx = canvas.getContext("2d", { willReadFrequently: true });

            let img, mCallback;
            MainUI.openImageSelector = function openImageSelector(callback) {
                mCallback = callback;
                dialog.showModal();
            };

            // 缩放和平移参数
            let minWidth = 0;
            let scale = 1;
            let minScale = 0.1;
            let maxScale = 10;
            let offsetX = 0;
            let offsetY = 0;


            let lastOffsetX, lastOffsetY;

            // 鼠标状态
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;


            // 绘制图片
            function drawImage() {

                // 边界限制
                offsetX = calculateBoundedOffset(offsetX, img.width, scale);
                offsetY = calculateBoundedOffset(offsetY, img.height, scale);

                if (offsetX === lastOffsetX && offsetY === lastOffsetY) {
                    return;
                }

                lastOffsetX = offsetX, lastOffsetY = offsetY;


                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 保存当前状态
                ctx.save();

                // 应用变换
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(scale, scale);

                ctx.translate(offsetX, offsetY);

                // 绘制图片（居中）
                ctx.drawImage(img, -img.width / 2, -img.height / 2);

                // 恢复状态
                ctx.restore();

            }

            document.addEventListener("keydown", function (ev) {
                if (dialog.open && img) {
                    // console.log(ev.code, ev.keyCode)
                    if (ev.code === "Space" || ev.keyCode === 32) {
                        ev.preventDefault();
                        offsetX = 0, offsetY = 0;
                    } else if (ev.code === "ArrowLeft" || ev.keyCode === 37 || ev.code === "keyA" || ev.keyCode === 65) {
                        ev.preventDefault();
                        offsetX -= 1;
                    } else if (ev.code === "ArrowRight" || ev.keyCode === 39 || ev.code === "keyD" || ev.keyCode === 68) {
                        ev.preventDefault();
                        offsetX += 1;
                    } else if (ev.code === "ArrowUp" || ev.keyCode === 38 || ev.code === "keyW" || ev.keyCode === 87) {
                        ev.preventDefault();
                        offsetY -= 1;
                    } else if (ev.code === "ArrowDown" || ev.keyCode === 40 || ev.code === "keyS" || ev.keyCode === 83) {
                        ev.preventDefault();
                        offsetY += 1;
                    }
                    drawImage();
                }
            });

            // 鼠标滚轮事件处理
            previewDiv.addEventListener('wheel', function (e) {
                if (!img) return;
                e.preventDefault();

                // 获取鼠标在Canvas上的位置
                const rect = canvas.getBoundingClientRect();
                const pointerX = e.clientX - rect.left;
                const pointerY = e.clientY - rect.top;

                // 计算鼠标在图片坐标系中的位置
                const imgX = (pointerX - canvas.width / 2) / scale - offsetX;
                const imgY = (pointerY - canvas.height / 2) / scale - offsetY;

                // 计算缩放因子
                const delta = -e.deltaY;
                let factor = 0.01;
                if (delta < 0) {
                    factor = -0.01;
                }

                // 应用缩放限制
                const newScale = Math.min(Math.max(scale + factor, minScale), maxScale);

                // 计算新的偏移量，使缩放以鼠标位置为中心
                offsetX = (pointerX - canvas.width / 2) / newScale - imgX;
                offsetY = (pointerY - canvas.height / 2) / newScale - imgY;

                scale = newScale;

                drawImage();
            });

            // 鼠标拖动事件处理
            previewDiv.addEventListener('pointerdown', function (e) {
                if (!img) return;
                e.preventDefault();
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
            });

            dialog.addEventListener('pointermove', function (e) {
                if (isDragging) {
                    e.preventDefault();
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;

                    offsetX += dx / scale;
                    offsetY += dy / scale;

                    lastX = e.clientX;
                    lastY = e.clientY;

                    drawImage();
                }
            });

            dialog.addEventListener('pointerup', function (e) {
                e.preventDefault();
                isDragging = false;
            });


            // 加载新图片
            fileInput.addEventListener("input", function (event) {
                event.preventDefault();
                if (fileInput.files.length === 0) return;
                img = new Image();
                img.addEventListener("load", function () {
                    minWidth = Math.min(img.naturalWidth, img.naturalHeight)
                    minScale = overlay / minWidth;
                    scale = minScale;
                    offsetX = 0;
                    offsetY = 0;
                    drawImage();
                }, { once: true });
                img.src = URL.createObjectURL(fileInput.files.item(0));
            });


            // 添加确认裁剪功能
            confirmInput.addEventListener("click", function cropImage(event) {
                event.preventDefault();
                event.stopPropagation();
                dialog.close();

                if (!img) return;

                const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                canvas.width = canvas.height = overlay;
                const ctx2 = canvas.getContext("2d");
                ctx2.putImageData(ctx.getImageData(172, 72, overlay, overlay), 0, 0);
                canvas.toBlob(mCallback, "image/png", 1);
            });
        }
    </script>

</template>


<template id="link-manager">
    <div id="link-manager" class="view dialog hide">
        <div class="flex-vertical dialog-box">
            <div class="flex-horizontal top">
                <div class="fill title">链接管理器<span class="help-hover" title="">ⓘ</span></div>
                <div class="button-box">
                    <button class="delete">删除</button>
                    <button class="save">保存</button>
                    <button class="close">关闭</button>
                </div>
            </div>
            <div class="fill dialog-content flex-horizontal">
                <div class="preview flex-horizontal">
                    <a class="link-button unselect" draggable="true"><span class="bg"></span><span
                            class="title">预览</span></a>
                </div>
                <div class="fill input-box">
                    <div class="subtitle">标题：</div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-title" value="预览"
                            autocomplete="off"></div>
                    <div class="subtitle">网址：</div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-url"
                            autocomplete="off"></div>
                    <div class="subtitle flex-horizontal space"><span>图标网址：（临时加载一次后缓存到浏览器存储）</span><label
                            class="checkbox"><input type="checkbox" id="link-manager-image-always"><span
                                class="text">每次都从网络加载</span></label></div>
                    <div class="input flex-vertical"><input class="unify" type="url" id="link-manager-image-url"
                            autocomplete="off"></div>
                    <div class="subtitle">图标缓存：（点击左侧预览图标可更换为本地图片）</div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-image-local"
                            readonly="readonly" autocomplete="off"></div>
                    <div class="subtitle flex-horizontal"><span>背景颜色：颜色选择器：</span><input class="unify" type="color"
                            id="link-manager-background-selector" value="#ffffff"><span>（实际以预览效果为准）</span></div>
                    <div class="input flex-vertical"><input class="unify" type="text" id="link-manager-background"
                            value="#ffffff" autocomplete="off"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        return function (root, MainUI, options) {
            const _link_manager = document.getElementById("link-manager");

            const _preview = _link_manager.querySelector(".preview");
            const _preview_background = _preview.querySelector(".preview>.link-button>span.bg");
            const _preview_title = _preview.querySelector(".preview>.link-button>span.title");

            const toString = (string, def = "") => String(string ? string : def);
            const _link_manager_input = {
                "title": {
                    e: _link_manager.querySelector("input#link-manager-title"),
                    set(string) {
                        _preview_title.textContent = this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "href": {
                    e: _link_manager.querySelector("input#link-manager-url"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "icon": {
                    e: _link_manager.querySelector("input#link-manager-image-url"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "local_icon": {
                    e: _link_manager.querySelector("input#link-manager-image-local"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                },
                "always": {
                    e: _link_manager.querySelector("input#link-manager-image-always"),
                    set(string) {
                        if (this.e.checked = Boolean(string)) {
                            _preview_background.style.setProperty("background-image", `url(${_link_manager_input.icon.e.value}))`);
                        } else {
                            _preview_background.style.setProperty("background-image", `url(${_link_manager_input.local_icon.e.value})`);
                        }
                    },
                    get() {
                        return this.e.checked
                    }
                },
                "background_color": {
                    e: _link_manager.querySelector("input#link-manager-background"),
                    set(string) {
                        const value = _link_manager_input.background_color.e.value = toString(string, "transparent");
                        _preview_background.style.setProperty("background-color", value);
                    },
                    get() {
                        return this.e.value.trim() || "transparent";
                    }
                },
                "selector": {
                    e: _link_manager.querySelector("#link-manager-background-selector"),
                    set(string) {
                        this.e.value = toString(string);
                    },
                    get() {
                        return this.e.value.trim()
                    }
                }
            };

            const needSaveKeys = ["title", "href", "icon", "local_icon", "always", "background_color"];
            _link_manager.querySelector(".close").addEventListener("click", function () {
                _link_manager.classList.add("hide");
            }, false);
            _link_manager.querySelector(".delete").addEventListener("click", function () {
                const id = Number(_link_manager.dataset.id);
                if (id < 0) {
                    return
                }
                if (confirm("确定要删除吗？")) {
                    MainUI.vm_links.data.splice(id, 1);
                    saveLocalConfigure();
                    _link_manager.classList.add("hide");
                }
            }, false);
            _link_manager.querySelector(".save").addEventListener("click", function () {

                const result = needSaveKeys.reduce(function (acc, key) {
                    acc[key] = _link_manager_input[key].get();
                    return acc;
                }, {});

                if (!result.href) {
                    return alert("网址不能为空！")
                }

                const id = Number(_link_manager.dataset.id);
                if (id < 0) {
                    MainUI.vm_links.data.push(result);
                } else {
                    MainUI.vm_links.data.splice(id, 1, result);
                }

                saveLocalConfigure();
                _link_manager.classList.add("hide");
            });

            _link_manager_input.title.e.addEventListener("input", function () {
                _preview_title.textContent = _link_manager_input.title.e.value;
            });
            _link_manager_input.icon.e.addEventListener("change", function () {
                // TODO
            });
            _preview_background.addEventListener("click", function () {
                MainUI.openImageSelector(function (blob) {
                    MainUI.loadImage(URL.createObjectURL(blob))
                        .then(image => MainUI.compressImage(image, 128, 128))
                        .then(function (dataURL) {
                            _link_manager_input.icon.e.value = "";
                            _preview_background.style.setProperty("background-image", `url(${_link_manager_input.local_icon.e.value = dataURL})`);
                        });
                });
            });
            _link_manager_input.selector.e.addEventListener("change", function () {
                _preview_background.style.setProperty("background-color", _link_manager_input.background_color.e.value = _link_manager_input.selector.e.value);
            });
            _link_manager_input.background_color.e.addEventListener("change", function () {
                _preview_background.style.setProperty("background-color", _link_manager_input.background_color.e.value);
            });

            MainUI.openLinkManager = function openLinkManager(index = "-1") {
                if ((_link_manager.dataset.id = index) >= 0) {
                    if (index >= MainUI.vm_links.data.length) {
                        return console.warn("IndexOutOfBoundsException");
                    }
                    const obj = MainUI.vm_links.data[index];
                    needSaveKeys.forEach(key => {
                        _link_manager_input[key]?.set(obj[key]);
                    });
                }
                _link_manager.classList.remove("hide");
            };
        }
    </script>
</template>